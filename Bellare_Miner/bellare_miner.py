import random  # Модуль для генерации случайных чисел
import sympy  # Модуль для работы с числами (поиск простых чисел и т. д.)

def mod_exp(a, b, m):
    """
    Возвращает (a^b) % m с использованием быстрого возведения в степень.
    """
    result = 1  # Начальное значение результата
    base = a % m  # Приведение a к модулю m
    while b > 0:
        if b % 2 == 1:  # Если текущий бит степени равен 1
            result = (result * base) % m  # Умножаем на основание и берём по модулю
        base = (base * base) % m  # Возводим основание в квадрат
        b //= 2  # Переход к следующему биту степени
    return result

def generate_primes(k):
    """
    Генерирует два случайных простых числа p и q длиной k/2 бит,
    такие, что p ≡ 3 (mod 4) и q ≡ 3 (mod 4).
    """
    while True:
        p = sympy.randprime(2**(k//2 - 1), 2**(k//2))  # Генерируем случайное простое число p
        q = sympy.randprime(2**(k//2 - 1), 2**(k//2))  # Генерируем случайное простое число q
        if p % 4 == 3 and q % 4 == 3:  # Проверяем условие p ≡ 3 (mod 4) и q ≡ 3 (mod 4)
            return p, q  # Возвращаем найденные p и q

def generate_keys(k, l, T):
    """
    Генерирует ключи:
    - Открытый ключ PK = (N, T, U)
    - Закрытый ключ SK_0 = (N, T, 0, S)
    """
    p, q = generate_primes(k)  # Генерация p и q
    N = p * q  # Вычисление модуля N
    S = [random.randint(1, N-1) for _ in range(l)]  # Выбор l случайных секретных чисел S_i
    U = [mod_exp(s, 2**(T + 1), N) for s in S]  # Вычисление U_i = S_i^(2^(T+1)) mod N
    SK_0 = (N, T, 0, S)  # Начальный секретный ключ
    PK = (N, T, U)  # Открытый ключ
    return PK, SK_0  # Возвращаем ключи

def update_key(SK_j_minus_1):
    """
    Обновляет секретный ключ SK_{j-1} -> SK_j.
    """
    N, T, j_minus_1, S_j_minus_1 = SK_j_minus_1  # Извлекаем параметры ключа
    if j_minus_1 == T:  # Если достигнуто максимальное количество обновлений, возвращаем None
        return None
    S_j = [mod_exp(s, 2, N) for s in S_j_minus_1]  # S_j = S_{j-1}^2 (mod N)
    return (N, T, j_minus_1 + 1, S_j)  # Возвращаем обновленный ключ

def sign(SK_j, M, H, l):
    """
    Создаёт цифровую подпись (j, (Y, Z)) для сообщения M.
    """
    N, T, j, S_j = SK_j  # Извлекаем параметры закрытого ключа
    R = random.randint(1, N-1)  # Выбираем случайное число R
    Y = mod_exp(R, 2**(T + 1 - j), N)  # Вычисляем Y = R^(2^(T+1-j)) mod N
    c = [H(i, Y, M) for i in range(1, l + 1)]  # Вычисляем хеши c_i
    Z = R  # Начальное значение Z
    for i in range(l):  # Вычисляем Z = R * Π S_i^c_i (mod N)
        Z = (Z * mod_exp(S_j[i], c[i], N)) % N
    return (j, (Y, Z))  # Возвращаем подпись

def verify(PK, M, signature, H, l):
    """
    Проверяет корректность подписи (j, (Y, Z)) для сообщения M.
    """
    N, T, U = PK  # Извлекаем параметры открытого ключа
    j, (Y, Z) = signature  # Извлекаем параметры подписи
    c = [H(i, Y, M) for i in range(1, l + 1)]  # Повторное вычисление хешей c_i
    lhs = mod_exp(Z, 2**(T + 1 - j), N)  # Возведение Z в степень
    rhs = Y  # Начальное значение правой части
    for i in range(l):  # Вычисление правой части сравнения
        rhs = (rhs * mod_exp(U[i], c[i], N)) % N
    return lhs == rhs  # Сравниваем левую и правую части

def hash_function(i, Y, M):
    """
    Простейшая хеш-функция (здесь для примера).
    Лучше использовать криптографически стойкую хеш-функцию.
    """
    return (i + Y + M) % 2**32  # Простое сложение аргументов по модулю 2^32

# Параметры схемы
k = 128  # Длина модуля N в битах
l = 5  # Количество секретных значений S
T = 10  # Максимальное количество обновлений

# Генерация ключей
PK, SK_0 = generate_keys(k, l, T)  # Создание открытого и закрытого ключей
SK_1 = update_key(SK_0)  # Обновление ключа

# Подписание сообщения
message = 12345  # Сообщение для подписи
signature = sign(SK_1, message, hash_function, l)  # Создание подписи

# Проверка подписи
is_valid = verify(PK, message, signature, hash_function, l)  # Проверка подписи
print("Подпись действительна:", is_valid)  # Вывод результата